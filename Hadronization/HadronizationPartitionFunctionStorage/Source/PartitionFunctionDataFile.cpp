// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "../Include/PartitionFunctionDataFile.h"

// ImportanceSamplingFunctionParameters
//

const ImportanceSamplingFunctionParameters::electricChargeFugacity_type& ImportanceSamplingFunctionParameters::
electricChargeFugacity () const
{
  return this->electricChargeFugacity_.get ();
}

ImportanceSamplingFunctionParameters::electricChargeFugacity_type& ImportanceSamplingFunctionParameters::
electricChargeFugacity ()
{
  return this->electricChargeFugacity_.get ();
}

void ImportanceSamplingFunctionParameters::
electricChargeFugacity (const electricChargeFugacity_type& x)
{
  this->electricChargeFugacity_.set (x);
}

const ImportanceSamplingFunctionParameters::baryonicChargeFugacity_type& ImportanceSamplingFunctionParameters::
baryonicChargeFugacity () const
{
  return this->baryonicChargeFugacity_.get ();
}

ImportanceSamplingFunctionParameters::baryonicChargeFugacity_type& ImportanceSamplingFunctionParameters::
baryonicChargeFugacity ()
{
  return this->baryonicChargeFugacity_.get ();
}

void ImportanceSamplingFunctionParameters::
baryonicChargeFugacity (const baryonicChargeFugacity_type& x)
{
  this->baryonicChargeFugacity_.set (x);
}

const ImportanceSamplingFunctionParameters::strangeChargeFugacity_type& ImportanceSamplingFunctionParameters::
strangeChargeFugacity () const
{
  return this->strangeChargeFugacity_.get ();
}

ImportanceSamplingFunctionParameters::strangeChargeFugacity_type& ImportanceSamplingFunctionParameters::
strangeChargeFugacity ()
{
  return this->strangeChargeFugacity_.get ();
}

void ImportanceSamplingFunctionParameters::
strangeChargeFugacity (const strangeChargeFugacity_type& x)
{
  this->strangeChargeFugacity_.set (x);
}

const ImportanceSamplingFunctionParameters::charmChargeFugacity_type& ImportanceSamplingFunctionParameters::
charmChargeFugacity () const
{
  return this->charmChargeFugacity_.get ();
}

ImportanceSamplingFunctionParameters::charmChargeFugacity_type& ImportanceSamplingFunctionParameters::
charmChargeFugacity ()
{
  return this->charmChargeFugacity_.get ();
}

void ImportanceSamplingFunctionParameters::
charmChargeFugacity (const charmChargeFugacity_type& x)
{
  this->charmChargeFugacity_.set (x);
}

const ImportanceSamplingFunctionParameters::bottomChargeFugacity_type& ImportanceSamplingFunctionParameters::
bottomChargeFugacity () const
{
  return this->bottomChargeFugacity_.get ();
}

ImportanceSamplingFunctionParameters::bottomChargeFugacity_type& ImportanceSamplingFunctionParameters::
bottomChargeFugacity ()
{
  return this->bottomChargeFugacity_.get ();
}

void ImportanceSamplingFunctionParameters::
bottomChargeFugacity (const bottomChargeFugacity_type& x)
{
  this->bottomChargeFugacity_.set (x);
}

const ImportanceSamplingFunctionParameters::temperature_type& ImportanceSamplingFunctionParameters::
temperature () const
{
  return this->temperature_.get ();
}

ImportanceSamplingFunctionParameters::temperature_type& ImportanceSamplingFunctionParameters::
temperature ()
{
  return this->temperature_.get ();
}

void ImportanceSamplingFunctionParameters::
temperature (const temperature_type& x)
{
  this->temperature_.set (x);
}


// PartitionFunctionGridElement
//

const PartitionFunctionGridElement::partitionFunctionGridElementIndex_type& PartitionFunctionGridElement::
partitionFunctionGridElementIndex () const
{
  return this->partitionFunctionGridElementIndex_.get ();
}

PartitionFunctionGridElement::partitionFunctionGridElementIndex_type& PartitionFunctionGridElement::
partitionFunctionGridElementIndex ()
{
  return this->partitionFunctionGridElementIndex_.get ();
}

void PartitionFunctionGridElement::
partitionFunctionGridElementIndex (const partitionFunctionGridElementIndex_type& x)
{
  this->partitionFunctionGridElementIndex_.set (x);
}

const PartitionFunctionGridElement::partitionFunctionValue_type& PartitionFunctionGridElement::
partitionFunctionValue () const
{
  return this->partitionFunctionValue_.get ();
}

PartitionFunctionGridElement::partitionFunctionValue_type& PartitionFunctionGridElement::
partitionFunctionValue ()
{
  return this->partitionFunctionValue_.get ();
}

void PartitionFunctionGridElement::
partitionFunctionValue (const partitionFunctionValue_type& x)
{
  this->partitionFunctionValue_.set (x);
}

const PartitionFunctionGridElement::partitionFunctionErrorValue_type& PartitionFunctionGridElement::
partitionFunctionErrorValue () const
{
  return this->partitionFunctionErrorValue_.get ();
}

PartitionFunctionGridElement::partitionFunctionErrorValue_type& PartitionFunctionGridElement::
partitionFunctionErrorValue ()
{
  return this->partitionFunctionErrorValue_.get ();
}

void PartitionFunctionGridElement::
partitionFunctionErrorValue (const partitionFunctionErrorValue_type& x)
{
  this->partitionFunctionErrorValue_.set (x);
}

const PartitionFunctionGridElement::numberChannelSamplings_type& PartitionFunctionGridElement::
numberChannelSamplings () const
{
  return this->numberChannelSamplings_.get ();
}

PartitionFunctionGridElement::numberChannelSamplings_type& PartitionFunctionGridElement::
numberChannelSamplings ()
{
  return this->numberChannelSamplings_.get ();
}

void PartitionFunctionGridElement::
numberChannelSamplings (const numberChannelSamplings_type& x)
{
  this->numberChannelSamplings_.set (x);
}

const PartitionFunctionGridElement::importanceSamplingFunctionParameters_optional& PartitionFunctionGridElement::
importanceSamplingFunctionParameters () const
{
  return this->importanceSamplingFunctionParameters_;
}

PartitionFunctionGridElement::importanceSamplingFunctionParameters_optional& PartitionFunctionGridElement::
importanceSamplingFunctionParameters ()
{
  return this->importanceSamplingFunctionParameters_;
}

void PartitionFunctionGridElement::
importanceSamplingFunctionParameters (const importanceSamplingFunctionParameters_type& x)
{
  this->importanceSamplingFunctionParameters_.set (x);
}

void PartitionFunctionGridElement::
importanceSamplingFunctionParameters (const importanceSamplingFunctionParameters_optional& x)
{
  this->importanceSamplingFunctionParameters_ = x;
}

void PartitionFunctionGridElement::
importanceSamplingFunctionParameters (::std::unique_ptr< importanceSamplingFunctionParameters_type > x)
{
  this->importanceSamplingFunctionParameters_.set (std::move (x));
}


// PartitionFunctionDataList
//

const PartitionFunctionDataList::partitionFunctionData_sequence& PartitionFunctionDataList::
partitionFunctionData () const
{
  return this->partitionFunctionData_;
}

PartitionFunctionDataList::partitionFunctionData_sequence& PartitionFunctionDataList::
partitionFunctionData ()
{
  return this->partitionFunctionData_;
}

void PartitionFunctionDataList::
partitionFunctionData (const partitionFunctionData_sequence& s)
{
  this->partitionFunctionData_ = s;
}

const PartitionFunctionDataList::length_type& PartitionFunctionDataList::
length () const
{
  return this->length_.get ();
}

PartitionFunctionDataList::length_type& PartitionFunctionDataList::
length ()
{
  return this->length_.get ();
}

void PartitionFunctionDataList::
length (const length_type& x)
{
  this->length_.set (x);
}


// PartitionFunctionDataFile
//

const PartitionFunctionDataFile::massValue_type& PartitionFunctionDataFile::
massValue () const
{
  return this->massValue_.get ();
}

PartitionFunctionDataFile::massValue_type& PartitionFunctionDataFile::
massValue ()
{
  return this->massValue_.get ();
}

void PartitionFunctionDataFile::
massValue (const massValue_type& x)
{
  this->massValue_.set (x);
}

const PartitionFunctionDataFile::partitionFunctionDataList_type& PartitionFunctionDataFile::
partitionFunctionDataList () const
{
  return this->partitionFunctionDataList_.get ();
}

PartitionFunctionDataFile::partitionFunctionDataList_type& PartitionFunctionDataFile::
partitionFunctionDataList ()
{
  return this->partitionFunctionDataList_.get ();
}

void PartitionFunctionDataFile::
partitionFunctionDataList (const partitionFunctionDataList_type& x)
{
  this->partitionFunctionDataList_.set (x);
}

void PartitionFunctionDataFile::
partitionFunctionDataList (::std::unique_ptr< partitionFunctionDataList_type > x)
{
  this->partitionFunctionDataList_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ImportanceSamplingFunctionParameters
//

ImportanceSamplingFunctionParameters::
ImportanceSamplingFunctionParameters (const electricChargeFugacity_type& electricChargeFugacity,
                                      const baryonicChargeFugacity_type& baryonicChargeFugacity,
                                      const strangeChargeFugacity_type& strangeChargeFugacity,
                                      const charmChargeFugacity_type& charmChargeFugacity,
                                      const bottomChargeFugacity_type& bottomChargeFugacity,
                                      const temperature_type& temperature)
: ::xml_schema::type (),
  electricChargeFugacity_ (electricChargeFugacity, this),
  baryonicChargeFugacity_ (baryonicChargeFugacity, this),
  strangeChargeFugacity_ (strangeChargeFugacity, this),
  charmChargeFugacity_ (charmChargeFugacity, this),
  bottomChargeFugacity_ (bottomChargeFugacity, this),
  temperature_ (temperature, this)
{
}

ImportanceSamplingFunctionParameters::
ImportanceSamplingFunctionParameters (const ImportanceSamplingFunctionParameters& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  electricChargeFugacity_ (x.electricChargeFugacity_, f, this),
  baryonicChargeFugacity_ (x.baryonicChargeFugacity_, f, this),
  strangeChargeFugacity_ (x.strangeChargeFugacity_, f, this),
  charmChargeFugacity_ (x.charmChargeFugacity_, f, this),
  bottomChargeFugacity_ (x.bottomChargeFugacity_, f, this),
  temperature_ (x.temperature_, f, this)
{
}

ImportanceSamplingFunctionParameters::
ImportanceSamplingFunctionParameters (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  electricChargeFugacity_ (this),
  baryonicChargeFugacity_ (this),
  strangeChargeFugacity_ (this),
  charmChargeFugacity_ (this),
  bottomChargeFugacity_ (this),
  temperature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ImportanceSamplingFunctionParameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // electricChargeFugacity
    //
    if (n.name () == "electricChargeFugacity" && n.namespace_ ().empty ())
    {
      if (!electricChargeFugacity_.present ())
      {
        this->electricChargeFugacity_.set (electricChargeFugacity_traits::create (i, f, this));
        continue;
      }
    }

    // baryonicChargeFugacity
    //
    if (n.name () == "baryonicChargeFugacity" && n.namespace_ ().empty ())
    {
      if (!baryonicChargeFugacity_.present ())
      {
        this->baryonicChargeFugacity_.set (baryonicChargeFugacity_traits::create (i, f, this));
        continue;
      }
    }

    // strangeChargeFugacity
    //
    if (n.name () == "strangeChargeFugacity" && n.namespace_ ().empty ())
    {
      if (!strangeChargeFugacity_.present ())
      {
        this->strangeChargeFugacity_.set (strangeChargeFugacity_traits::create (i, f, this));
        continue;
      }
    }

    // charmChargeFugacity
    //
    if (n.name () == "charmChargeFugacity" && n.namespace_ ().empty ())
    {
      if (!charmChargeFugacity_.present ())
      {
        this->charmChargeFugacity_.set (charmChargeFugacity_traits::create (i, f, this));
        continue;
      }
    }

    // bottomChargeFugacity
    //
    if (n.name () == "bottomChargeFugacity" && n.namespace_ ().empty ())
    {
      if (!bottomChargeFugacity_.present ())
      {
        this->bottomChargeFugacity_.set (bottomChargeFugacity_traits::create (i, f, this));
        continue;
      }
    }

    // temperature
    //
    if (n.name () == "temperature" && n.namespace_ ().empty ())
    {
      if (!temperature_.present ())
      {
        this->temperature_.set (temperature_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!electricChargeFugacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "electricChargeFugacity",
      "");
  }

  if (!baryonicChargeFugacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baryonicChargeFugacity",
      "");
  }

  if (!strangeChargeFugacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "strangeChargeFugacity",
      "");
  }

  if (!charmChargeFugacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "charmChargeFugacity",
      "");
  }

  if (!bottomChargeFugacity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottomChargeFugacity",
      "");
  }

  if (!temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temperature",
      "");
  }
}

ImportanceSamplingFunctionParameters* ImportanceSamplingFunctionParameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ImportanceSamplingFunctionParameters (*this, f, c);
}

ImportanceSamplingFunctionParameters& ImportanceSamplingFunctionParameters::
operator= (const ImportanceSamplingFunctionParameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->electricChargeFugacity_ = x.electricChargeFugacity_;
    this->baryonicChargeFugacity_ = x.baryonicChargeFugacity_;
    this->strangeChargeFugacity_ = x.strangeChargeFugacity_;
    this->charmChargeFugacity_ = x.charmChargeFugacity_;
    this->bottomChargeFugacity_ = x.bottomChargeFugacity_;
    this->temperature_ = x.temperature_;
  }

  return *this;
}

ImportanceSamplingFunctionParameters::
~ImportanceSamplingFunctionParameters ()
{
}

// PartitionFunctionGridElement
//

PartitionFunctionGridElement::
PartitionFunctionGridElement (const partitionFunctionGridElementIndex_type& partitionFunctionGridElementIndex,
                              const partitionFunctionValue_type& partitionFunctionValue,
                              const partitionFunctionErrorValue_type& partitionFunctionErrorValue,
                              const numberChannelSamplings_type& numberChannelSamplings)
: ::xml_schema::type (),
  partitionFunctionGridElementIndex_ (partitionFunctionGridElementIndex, this),
  partitionFunctionValue_ (partitionFunctionValue, this),
  partitionFunctionErrorValue_ (partitionFunctionErrorValue, this),
  numberChannelSamplings_ (numberChannelSamplings, this),
  importanceSamplingFunctionParameters_ (this)
{
}

PartitionFunctionGridElement::
PartitionFunctionGridElement (const PartitionFunctionGridElement& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  partitionFunctionGridElementIndex_ (x.partitionFunctionGridElementIndex_, f, this),
  partitionFunctionValue_ (x.partitionFunctionValue_, f, this),
  partitionFunctionErrorValue_ (x.partitionFunctionErrorValue_, f, this),
  numberChannelSamplings_ (x.numberChannelSamplings_, f, this),
  importanceSamplingFunctionParameters_ (x.importanceSamplingFunctionParameters_, f, this)
{
}

PartitionFunctionGridElement::
PartitionFunctionGridElement (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  partitionFunctionGridElementIndex_ (this),
  partitionFunctionValue_ (this),
  partitionFunctionErrorValue_ (this),
  numberChannelSamplings_ (this),
  importanceSamplingFunctionParameters_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PartitionFunctionGridElement::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // partitionFunctionGridElementIndex
    //
    if (n.name () == "partitionFunctionGridElementIndex" && n.namespace_ ().empty ())
    {
      if (!partitionFunctionGridElementIndex_.present ())
      {
        this->partitionFunctionGridElementIndex_.set (partitionFunctionGridElementIndex_traits::create (i, f, this));
        continue;
      }
    }

    // partitionFunctionValue
    //
    if (n.name () == "partitionFunctionValue" && n.namespace_ ().empty ())
    {
      if (!partitionFunctionValue_.present ())
      {
        this->partitionFunctionValue_.set (partitionFunctionValue_traits::create (i, f, this));
        continue;
      }
    }

    // partitionFunctionErrorValue
    //
    if (n.name () == "partitionFunctionErrorValue" && n.namespace_ ().empty ())
    {
      if (!partitionFunctionErrorValue_.present ())
      {
        this->partitionFunctionErrorValue_.set (partitionFunctionErrorValue_traits::create (i, f, this));
        continue;
      }
    }

    // numberChannelSamplings
    //
    if (n.name () == "numberChannelSamplings" && n.namespace_ ().empty ())
    {
      if (!numberChannelSamplings_.present ())
      {
        this->numberChannelSamplings_.set (numberChannelSamplings_traits::create (i, f, this));
        continue;
      }
    }

    // importanceSamplingFunctionParameters
    //
    if (n.name () == "importanceSamplingFunctionParameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< importanceSamplingFunctionParameters_type > r (
        importanceSamplingFunctionParameters_traits::create (i, f, this));

      if (!this->importanceSamplingFunctionParameters_)
      {
        this->importanceSamplingFunctionParameters_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!partitionFunctionGridElementIndex_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "partitionFunctionGridElementIndex",
      "");
  }

  if (!partitionFunctionValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "partitionFunctionValue",
      "");
  }

  if (!partitionFunctionErrorValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "partitionFunctionErrorValue",
      "");
  }

  if (!numberChannelSamplings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numberChannelSamplings",
      "");
  }
}

PartitionFunctionGridElement* PartitionFunctionGridElement::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PartitionFunctionGridElement (*this, f, c);
}

PartitionFunctionGridElement& PartitionFunctionGridElement::
operator= (const PartitionFunctionGridElement& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->partitionFunctionGridElementIndex_ = x.partitionFunctionGridElementIndex_;
    this->partitionFunctionValue_ = x.partitionFunctionValue_;
    this->partitionFunctionErrorValue_ = x.partitionFunctionErrorValue_;
    this->numberChannelSamplings_ = x.numberChannelSamplings_;
    this->importanceSamplingFunctionParameters_ = x.importanceSamplingFunctionParameters_;
  }

  return *this;
}

PartitionFunctionGridElement::
~PartitionFunctionGridElement ()
{
}

// PartitionFunctionDataList
//

PartitionFunctionDataList::
PartitionFunctionDataList (const length_type& length)
: ::xml_schema::type (),
  partitionFunctionData_ (this),
  length_ (length, this)
{
}

PartitionFunctionDataList::
PartitionFunctionDataList (const PartitionFunctionDataList& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  partitionFunctionData_ (x.partitionFunctionData_, f, this),
  length_ (x.length_, f, this)
{
}

PartitionFunctionDataList::
PartitionFunctionDataList (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  partitionFunctionData_ (this),
  length_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void PartitionFunctionDataList::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // partitionFunctionData
    //
    if (n.name () == "partitionFunctionData" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< partitionFunctionData_type > r (
        partitionFunctionData_traits::create (i, f, this));

      this->partitionFunctionData_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length_.set (length_traits::create (i, f, this));
      continue;
    }
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }
}

PartitionFunctionDataList* PartitionFunctionDataList::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PartitionFunctionDataList (*this, f, c);
}

PartitionFunctionDataList& PartitionFunctionDataList::
operator= (const PartitionFunctionDataList& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->partitionFunctionData_ = x.partitionFunctionData_;
    this->length_ = x.length_;
  }

  return *this;
}

PartitionFunctionDataList::
~PartitionFunctionDataList ()
{
}

// PartitionFunctionDataFile
//

PartitionFunctionDataFile::
PartitionFunctionDataFile (const massValue_type& massValue,
                           const partitionFunctionDataList_type& partitionFunctionDataList)
: ::xml_schema::type (),
  massValue_ (massValue, this),
  partitionFunctionDataList_ (partitionFunctionDataList, this)
{
}

PartitionFunctionDataFile::
PartitionFunctionDataFile (const massValue_type& massValue,
                           ::std::unique_ptr< partitionFunctionDataList_type > partitionFunctionDataList)
: ::xml_schema::type (),
  massValue_ (massValue, this),
  partitionFunctionDataList_ (std::move (partitionFunctionDataList), this)
{
}

PartitionFunctionDataFile::
PartitionFunctionDataFile (const PartitionFunctionDataFile& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  massValue_ (x.massValue_, f, this),
  partitionFunctionDataList_ (x.partitionFunctionDataList_, f, this)
{
}

PartitionFunctionDataFile::
PartitionFunctionDataFile (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  massValue_ (this),
  partitionFunctionDataList_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PartitionFunctionDataFile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // massValue
    //
    if (n.name () == "massValue" && n.namespace_ ().empty ())
    {
      if (!massValue_.present ())
      {
        this->massValue_.set (massValue_traits::create (i, f, this));
        continue;
      }
    }

    // partitionFunctionDataList
    //
    if (n.name () == "partitionFunctionDataList" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< partitionFunctionDataList_type > r (
        partitionFunctionDataList_traits::create (i, f, this));

      if (!partitionFunctionDataList_.present ())
      {
        this->partitionFunctionDataList_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!massValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "massValue",
      "");
  }

  if (!partitionFunctionDataList_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "partitionFunctionDataList",
      "");
  }
}

PartitionFunctionDataFile* PartitionFunctionDataFile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PartitionFunctionDataFile (*this, f, c);
}

PartitionFunctionDataFile& PartitionFunctionDataFile::
operator= (const PartitionFunctionDataFile& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->massValue_ = x.massValue_;
    this->partitionFunctionDataList_ = x.partitionFunctionDataList_;
  }

  return *this;
}

PartitionFunctionDataFile::
~PartitionFunctionDataFile ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PartitionFunctionDataFile_ (isrc, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PartitionFunctionDataFile_ (isrc, h, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::PartitionFunctionDataFile_ (isrc, h, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PartitionFunctionDataFile_ (isrc, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PartitionFunctionDataFile_ (isrc, h, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::PartitionFunctionDataFile_ (isrc, h, f, p);
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::PartitionFunctionDataFile > (
    ::PartitionFunctionDataFile_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::PartitionFunctionDataFile > (
      ::PartitionFunctionDataFile_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "PartitionFunctionDataFile" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::PartitionFunctionDataFile > r (
      ::xsd::cxx::tree::traits< ::PartitionFunctionDataFile, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "PartitionFunctionDataFile",
    "");
}

::std::unique_ptr< ::PartitionFunctionDataFile >
PartitionFunctionDataFile_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "PartitionFunctionDataFile" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::PartitionFunctionDataFile > r (
      ::xsd::cxx::tree::traits< ::PartitionFunctionDataFile, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "PartitionFunctionDataFile",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const ImportanceSamplingFunctionParameters& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // electricChargeFugacity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "electricChargeFugacity",
        e));

    s << ::xml_schema::as_double(i.electricChargeFugacity ());
  }

  // baryonicChargeFugacity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baryonicChargeFugacity",
        e));

    s << ::xml_schema::as_double(i.baryonicChargeFugacity ());
  }

  // strangeChargeFugacity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "strangeChargeFugacity",
        e));

    s << ::xml_schema::as_double(i.strangeChargeFugacity ());
  }

  // charmChargeFugacity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "charmChargeFugacity",
        e));

    s << ::xml_schema::as_double(i.charmChargeFugacity ());
  }

  // bottomChargeFugacity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "bottomChargeFugacity",
        e));

    s << ::xml_schema::as_double(i.bottomChargeFugacity ());
  }

  // temperature
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "temperature",
        e));

    s << ::xml_schema::as_double(i.temperature ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PartitionFunctionGridElement& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // partitionFunctionGridElementIndex
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partitionFunctionGridElementIndex",
        e));

    s << i.partitionFunctionGridElementIndex ();
  }

  // partitionFunctionValue
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partitionFunctionValue",
        e));

    s << ::xml_schema::as_double(i.partitionFunctionValue ());
  }

  // partitionFunctionErrorValue
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partitionFunctionErrorValue",
        e));

    s << ::xml_schema::as_double(i.partitionFunctionErrorValue ());
  }

  // numberChannelSamplings
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numberChannelSamplings",
        e));

    s << i.numberChannelSamplings ();
  }

  // importanceSamplingFunctionParameters
  //
  if (i.importanceSamplingFunctionParameters ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "importanceSamplingFunctionParameters",
        e));

    s << *i.importanceSamplingFunctionParameters ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PartitionFunctionDataList& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // partitionFunctionData
  //
  for (PartitionFunctionDataList::partitionFunctionData_const_iterator
       b (i.partitionFunctionData ().begin ()), n (i.partitionFunctionData ().end ());
       b != n; ++b)
  {
    const PartitionFunctionDataList::partitionFunctionData_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partitionFunctionData",
        e));

    s << x;
  }

  // length
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "length",
        e));

    a << i.length ();
  }
}

void
PartitionFunctionDataFile_ (::std::ostream& o,
                            const ::PartitionFunctionDataFile& s,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
PartitionFunctionDataFile_ (::std::ostream& o,
                            const ::PartitionFunctionDataFile& s,
                            ::xml_schema::error_handler& h,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
PartitionFunctionDataFile_ (::std::ostream& o,
                            const ::PartitionFunctionDataFile& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
PartitionFunctionDataFile_ (::xercesc::XMLFormatTarget& t,
                            const ::PartitionFunctionDataFile& s,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
PartitionFunctionDataFile_ (::xercesc::XMLFormatTarget& t,
                            const ::PartitionFunctionDataFile& s,
                            ::xml_schema::error_handler& h,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
PartitionFunctionDataFile_ (::xercesc::XMLFormatTarget& t,
                            const ::PartitionFunctionDataFile& s,
                            ::xercesc::DOMErrorHandler& h,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::string& e,
                            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::PartitionFunctionDataFile_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
PartitionFunctionDataFile_ (::xercesc::DOMDocument& d,
                            const ::PartitionFunctionDataFile& s,
                            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "PartitionFunctionDataFile" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "PartitionFunctionDataFile",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
PartitionFunctionDataFile_ (const ::PartitionFunctionDataFile& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "PartitionFunctionDataFile",
      "",
      m, f));

  ::PartitionFunctionDataFile_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const PartitionFunctionDataFile& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // massValue
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "massValue",
        e));

    s << ::xml_schema::as_double(i.massValue ());
  }

  // partitionFunctionDataList
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "partitionFunctionDataList",
        e));

    s << i.partitionFunctionDataList ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

